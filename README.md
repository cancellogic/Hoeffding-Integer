# Integer-Hoeffding
This is Wassley Hoeffding's 1948 equation for detecting -frequently nonlinear- relationships in data or variables.  In this version, the association value is computed with integers calculation, and not normalized (please only compare same n sample sizes) or shaped to a probability (higher values do have stronger relationships- good for detection of better models in machine learning or genetic algorithm health assessment -- but you won't know if a +81 difference is a miserable or vast improvement). Coded in Rust for partially ordinal types (compare {"g","e","n","e","r","i","c","s"} and {3.0,1.0,4.0,1.0,5.0,4.0,3.5,6.1})
# In defense of comprimises:
I didn't compute the whole function.  Roughly normalize the result if you want with division by ((n*(n-1)*(n-2)*(n-3)*(n-4))/30).  I didn't do this because I needed to for allow missing values, and Genetic Algorthim health functions can unhelpfully evolve towards models that return high correlation despite being largely impossible to compute (infities, undefined value, overflow, underflow).  And a few missing values doesn't automatically mean a given model is useless for evolution.  So if one model returns n results and another (n-10) results - I personally use the non-normalized value to judge the better - admittedly without formal mathematical proof that doing so is reasonable.
Generic functions like this one can cause slow compiles as n*n versions are made for n (every) partial ordinal type.  For the data miner, it isn't that unusual to compare integers and floats to characters or booleans, so this algorithm can do that, while most published Hoeffding discriminators are type constrained.    
No probability is reported.  There seem to be about 20+ papers published in the last 60 years in this area... many claiming easy, simplified, no need for an infinite chain of perfectly random bell curve distributed data points to define the probability function for each n because Eugen Slutsky's theorm or Lorenz attractors for even odd n converge to 3 significant digits (99.9%) or something.  And I understand enough of the math to know I should stop here, with unanswered questions and that someone with a post doctorate degree in number theory or statistics would probably be ideal to take this further.   
Rust is pretty fast.  Integer math is pretty fast.  This code is hopefully, fast compared to other Hoeffding statistics - but sorting & ranking uses a lot of time in this function.  If you are short on time, short on compute power, or certain you have a linear model - please strongly consider Pearson's R correlation (maybe crates.io/crates/ndarray-stats). 
